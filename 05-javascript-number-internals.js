let a = 34.54442;
console.log(a.toFixed(2));
console.log(typeof a.toFixed(2));
//it return string
//it do not change the primitives number a it just return a new string 

console.log(a.toPrecision(3));


//Create number as object 
let b = new Number(50);
console.log(b);
console.log(Number(b));
console.log(typeof b);

//when use new then create as object

//but quotation is that devang, should we use this method? why
//I would say Big NO
//useless method

let Obj1 = new Number(25);
let Obj2 = new Number(25);

console.log(Obj1==Obj2);
console.log(Obj1===Obj2);

//object can't be compare as the normal primitives 
//If obj2 is pointing to same reference of the obj1 then it become true

console.log("Now obj2 is pointing to Obj1 reference!");
Obj2 = Obj1;
console.log(Obj1==Obj2);
console.log(Obj1===Obj2);

// Why he says "Big NO" to new Number()
// Using new Number() is considered bad practice in the industry because:
// It is slower (uses more memory).
// It breaks logical comparisons (as shown in his Obj1 == Obj2 example).
// It makes code harder to read

console.log(`--Boolean--`);

console.log(Boolean(new Number(0)));
console.log(Boolean(new Number(1)));
console.log(Boolean({}));

//in Boolean if object is empty then still it return true!
//if reference exist in heap then it return true 
console.log(Boolean(new Number(null)));

//so non-primitives: references bases compare
//so primitives: copy by value


//Next question can be that in primitives we use let a = 34; and we can use the a.toString(); 
//but we didn't make the toString() || .toFixed() function so why we can call it?
//JavaScript Does Something Smart (Auto-Boxing)

// When you do:

// a.toString();


// JavaScript secretly does this internally:

// new Number(34).toString();


// It temporarily wraps the primitive 34 inside a Number object.

// This process is called:

// =========> Autoboxing

// It temporarily converts primitive → object
// so that you can use object methods.
//but, Where Does toString() Come From?

// All number objects inherit from:

// Number.prototype


// And inside Number.prototype there are methods like:

// toString()

// toFixed()

// toExponential()

// etc.

// So internally the chain looks like this:

// 34 (primitive)
//    ↓ autoboxing
// Number Object
//    ↓
// Number.prototype
//    ↓
// Object.prototype


// That’s why a.toString() works.

// Important: Object Is Temporary

// JavaScript does this:

// Wrap primitive in object

// Call method

// Destroy wrapper object

// So this works:

// let a = 34;
// console.log(a.toString()); // "34"


// But this does NOT work:

// let a = 34;
// a.newProp = "hello";
// console.log(a.newProp); // undefined


// Because the wrapper object gets destroyed immediately.


console.log(`--- Math ---`);
console.log(Math.abs(-6));
console.log(Math.PI);
console.log(Math.floor(4.3));
console.log(Math.ceil(4.4));
console.log(Math.log10(10));
console.log(Math.max(10,34,54,3,45,65,34));
console.log(Math.min(10,34,54,3,45,65,34));
console.log("Random Value generated: "+Math.random());//0-1 , 0 is included but 1 is not

console.log(parseInt(Math.random()*10));
//The Danger of Scientific Notation
// parseInt can produce weird bugs with very small or large numbers. 
// it can work but not ideal
// For example, parseInt(0.0000005) returns 5 because the string representation of that number is "5e-7", and parseInt just sees the "5" at the start.

//use floor best choice 

console.log(Math.floor((Math.random()*10))+1); // 1 to 10


let max =50;
let min =10;
console.log(Math.round(Math.random()*(max-min+1))+min);




console.log("Your OTP is "+Math.floor(Math.random() * (9999 - 1000 + 1))) + 1000;
console.log("Please do not share with anyone.");
//can we use to generate the OTP (ONE TIME PASSWORD) SYSTEM?
//IMPORTANT: NEVER DO IT
//First thing can you make a function which return random value between 0 to 0.9999. answer is no
//most of the programming language actually never return a truly random number.
//code is instruction based.
//most popular approach is the time. because is changing. so we can get the millisecond and do some process and return it.
//These are generated by a deterministic algorithm starting from a "seed" value.
//so in real world, crypto libraries are used for otp generating 


//in crypto 
//they may use current mouse pointer coordinate + current cpu/ram usage + current thread running in system etc...
//even the person know the code still can't guess the otp 
//in time-based from multiple otp can guess next outcome


// Recommended Approaches for Converting Decimals to Integers
// The best approach depends on the desired rounding behavior and the programming language being used.
// If you want to round to the nearest integer (standard rounding):
// Use Math.round() (JavaScript) or similar methods in other languages (e.g., Math.round() in Java).
// If you want to truncate the decimal part (remove everything after the decimal point):
// Use Math.trunc() (JavaScript).
// Use a type cast (e.g., (int) myDouble in Java or C#).

//but why not to use the parseInt? 

/*
it is not the best approach for handling general decimal numbers when the goal is to perform an accurate conversion
to an integer. It truncates the decimal part without any rounding and has behavioral quirks, 
especially in JavaScript, that make other methods safer and more reliable. 

Why parseInt() is Not Best for Decimal Conversion
Truncation, not Rounding: parseInt() stops parsing when it hits a non-numeric character like a decimal point (.), effectively truncating the number towards zero (e.g., parseInt("4.99") yields 4). This is different from mathematical rounding.
Partial Parsing: It is "forgiving" and will return an integer from the beginning of a string even if the rest of the string contains non-numeric characters (e.g., parseInt("42px") returns 42). This can mask errors if you expect the entire string to be a valid number.
Radix Issues: In older JavaScript versions, omitting the optional radix (number base) parameter could lead to unexpected behavior with leading zeros (e.g., "010" being interpreted as octal). While modern standards default to decimal (base 10), it is still considered best 
practice to always specify the radix for consistency and clarity (e.g., parseInt(str, 10)).
*/